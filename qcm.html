<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>QCM Optimisation SQL - PostgreSQL</title>
<style>
  body {
    font-family: "Inter", sans-serif;
    background: #f7f8fa;
    color: #222;
    padding: 20px;
    max-width: 800px;
    margin: auto;
  }
  h1 {
    text-align: center;
    color: #0a3d62;
  }
  .question-box {
    background: white;
    padding: 20px;
    margin-top: 20px;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  .question {
    font-size: 1.2em;
    margin-bottom: 10px;
  }
  .choices button {
    display: block;
    width: 100%;
    text-align: left;
    padding: 10px;
    margin: 6px 0;
    border: 1px solid #ccc;
    background: #fff;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .choices button:hover { background: #f0f0f0; }
  .choices button.correct { background: #c8e6c9; border-color: #2e7d32; }
  .choices button.incorrect { background: #ffcdd2; border-color: #c62828; }
  .explanation {
    margin-top: 10px;
    background: #e3f2fd;
    padding: 10px;
    border-left: 4px solid #1976d2;
    border-radius: 6px;
  }
  .next-btn {
    background: #0a3d62;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    margin-top: 15px;
    cursor: pointer;
  }
  .next-btn:hover { background: #07406b; }
</style>
</head>
<body>

<h1>QCM - Optimisation des RequÃªtes SQL (PostgreSQL)</h1>
<div id="quiz"></div>

<script>
const questions = [
  {
    q: "1ï¸âƒ£ Quelle commande permet dâ€™analyser le plan dâ€™exÃ©cution dâ€™une requÃªte dans PostgreSQL ?",
    choices: ["ANALYZE QUERY", "EXPLAIN ANALYZE", "SHOW EXECUTION PLAN", "DESCRIBE ANALYZE"],
    correct: 1,
    exp: "âœ… La commande EXPLAIN ANALYZE exÃ©cute la requÃªte et affiche le plan dâ€™exÃ©cution rÃ©el avec les temps mesurÃ©s."
  },
  {
    q: "2ï¸âƒ£ Que signifie 'Seq Scan' dans un plan dâ€™exÃ©cution ?",
    choices: [
      "PostgreSQL lit toute la table sÃ©quentiellement",
      "PostgreSQL lit les lignes dans lâ€™ordre dâ€™un index",
      "PostgreSQL trie les rÃ©sultats avant dâ€™afficher",
      "PostgreSQL lit seulement les lignes filtrÃ©es"
    ],
    correct: 0,
    exp: "ğŸ” 'Seq Scan' = lecture sÃ©quentielle de toute la table, ligne par ligne, sans utiliser dâ€™index."
  },
  {
    q: "3ï¸âƒ£ Pourquoi PostgreSQL utilise parfois un 'Parallel Seq Scan' ?",
    choices: [
      "Pour corriger une erreur de donnÃ©es",
      "Pour rÃ©partir la lecture de la table entre plusieurs processus",
      "Parce quâ€™un index est manquant",
      "Pour ordonner les rÃ©sultats plus vite"
    ],
    correct: 1,
    exp: "âš™ï¸ Le 'Parallel Seq Scan' permet Ã  plusieurs workers de lire la table en parallÃ¨le pour accÃ©lÃ©rer les requÃªtes lourdes."
  },
  {
    q: "4ï¸âƒ£ Que reprÃ©sente la valeur 'Rows Removed by Filter' dans un EXPLAIN ANALYZE ?",
    choices: [
      "Le nombre de lignes insÃ©rÃ©es",
      "Le nombre de lignes rejetÃ©es par le WHERE",
      "Le nombre de lignes mises Ã  jour",
      "Le nombre total de lignes lues"
    ],
    correct: 1,
    exp: "ğŸ“Š 'Rows Removed by Filter' indique combien de lignes ont Ã©tÃ© lues mais Ã©liminÃ©es par la condition WHERE."
  },
  {
    q: "5ï¸âƒ£ CrÃ©er un index sur start_year permet dâ€™optimiserâ€¦",
    choices: [
      "Les jointures entre tables",
      "Les requÃªtes avec un filtre sur start_year",
      "Les opÃ©rations dâ€™insertion",
      "Les requÃªtes dâ€™agrÃ©gation"
    ],
    correct: 1,
    exp: "ğŸ“ˆ Les index amÃ©liorent les recherches filtrant sur la colonne indexÃ©e, ici start_year."
  },
  {
    q: "6ï¸âƒ£ Que signifie 'Bitmap Index Scan' ?",
    choices: [
      "Lecture directe des lignes dans lâ€™ordre de lâ€™index",
      "PostgreSQL construit une carte (bitmap) des pages Ã  lire via lâ€™index",
      "Lecture sÃ©quentielle des blocs",
      "Lecture des lignes dans le cache"
    ],
    correct: 1,
    exp: "ğŸ§© 'Bitmap Index Scan' lit les identifiants de lignes via lâ€™index, puis un 'Bitmap Heap Scan' lit les pages correspondantes."
  },
  {
    q: "7ï¸âƒ£ Pourquoi sÃ©lectionner moins de colonnes (au lieu de SELECT *) peut accÃ©lÃ©rer une requÃªte ?",
    choices: [
      "Moins de donnÃ©es Ã  lire et Ã  transfÃ©rer",
      "PostgreSQL optimise mieux les jointures",
      "Lâ€™index devient plus grand",
      "Les filtres WHERE deviennent plus rapides"
    ],
    correct: 0,
    exp: "ğŸš€ Lire moins de colonnes signifie moins dâ€™E/S disque et de transfert mÃ©moire â†’ exÃ©cution plus rapide."
  },
  {
    q: "8ï¸âƒ£ Un index composite sur (start_year, title_type) aide surtout quandâ€¦",
    choices: [
      "La requÃªte filtre uniquement sur title_type",
      "La requÃªte filtre sur start_year et title_type",
      "La requÃªte trie sur une autre colonne",
      "On fait une jointure sur tconst"
    ],
    correct: 1,
    exp: "ğŸ”¢ Un index composite est efficace quand les deux colonnes sont utilisÃ©es ensemble dans un WHERE ou ORDER BY."
  },
  {
    q: "9ï¸âƒ£ Dans une jointure entre title_basics et title_ratings, quel algorithme est souvent utilisÃ© pour des tables grandes ?",
    choices: ["Nested Loop", "Merge Join", "Hash Join", "Bitmap Join"],
    correct: 2,
    exp: "ğŸ’¡ Le 'Hash Join' est le plus courant pour les grandes tables non triÃ©es, car il construit une table de hachage en mÃ©moire."
  },
  {
    q: "ğŸ”Ÿ Pourquoi PostgreSQL abandonne parfois le parallÃ©lisme aprÃ¨s ajout dâ€™un index efficace ?",
    choices: [
      "Parce que lâ€™index rend le plan dÃ©jÃ  assez rapide",
      "Parce que le parallÃ©lisme nâ€™est pas compatible avec les index",
      "Parce que le cache est plein",
      "Parce que EXPLAIN ANALYZE est dÃ©sactivÃ©"
    ],
    correct: 0,
    exp: "ğŸ§  Si un index rend le plan trÃ¨s rapide, PostgreSQL estime que le coÃ»t du parallÃ©lisme ne se justifie plus."
  },
  {
    q: "11ï¸âƒ£ Quand un index est-il le plus efficace ?",
    choices: [
      "Sur les colonnes peu distinctes (faible cardinalitÃ©)",
      "Sur les colonnes trÃ¨s distinctes (forte cardinalitÃ©)",
      "Sur toutes les colonnes",
      "Uniquement sur les clÃ©s Ã©trangÃ¨res"
    ],
    correct: 1,
    exp: "ğŸ¯ Les index sont efficaces quand la colonne contient beaucoup de valeurs diffÃ©rentes (forte sÃ©lectivitÃ©)."
  },
  {
    q: "12ï¸âƒ£ Quel type dâ€™index utiliser pour une recherche exacte ?",
    choices: ["GIN", "BRIN", "B-Tree", "HashMap"],
    correct: 2,
    exp: "ğŸ“˜ Le B-Tree est lâ€™index standard pour les recherches exactes (=) et les intervalles (<, >)."
  },
  {
    q: "13ï¸âƒ£ Quand un index composite est-il particuliÃ¨rement efficace ?",
    choices: [
      "Quand on filtre sur la premiÃ¨re colonne seulement",
      "Quand on filtre sur plusieurs colonnes du mÃªme index",
      "Quand on trie par une autre colonne",
      "Quand on fait un INSERT"
    ],
    correct: 1,
    exp: "ğŸ§® Lâ€™intÃ©rÃªt dâ€™un index composite est de combiner plusieurs colonnes dans un mÃªme plan dâ€™accÃ¨s."
  },
  {
    q: "14ï¸âƒ£ Que signifie 'Heap Blocks Read' dans EXPLAIN ANALYZE ?",
    choices: [
      "Nombre total de lignes insÃ©rÃ©es",
      "Nombre de blocs disque lus pour accÃ©der aux lignes",
      "Nombre dâ€™index utilisÃ©s",
      "Taille du cache PostgreSQL"
    ],
    correct: 1,
    exp: "ğŸ“¦ 'Heap Blocks Read' mesure les blocs physiques lus depuis le disque â€” indicateur du coÃ»t I/O."
  },
  {
    q: "15ï¸âƒ£ Pourquoi un 'covering index' est-il idÃ©al dans certains cas ?",
    choices: [
      "Parce quâ€™il inclut toutes les colonnes nÃ©cessaires Ã  la requÃªte",
      "Parce quâ€™il augmente la taille de la table",
      "Parce quâ€™il accÃ©lÃ¨re uniquement les jointures",
      "Parce quâ€™il dÃ©sactive le cache"
    ],
    correct: 0,
    exp: "ğŸª¶ Un 'covering index' contient toutes les colonnes nÃ©cessaires â€” PostgreSQL nâ€™a pas besoin de retourner Ã  la table."
  }
];

let current = 0;
let score = 0;

function showQuestion() {
  const q = questions[current];
  const quiz = document.getElementById('quiz');
  quiz.innerHTML = `
    <div class="question-box">
      <div class="question">${q.q}</div>
      <div class="choices">
        ${q.choices.map((c, i) => `<button onclick="checkAnswer(${i})">${c}</button>`).join("")}
      </div>
    </div>
  `;
}

function checkAnswer(i) {
  const q = questions[current];
  const buttons = document.querySelectorAll('.choices button');
  buttons.forEach((btn, idx) => {
    btn.disabled = true;
    if (idx === q.correct) btn.classList.add('correct');
    if (idx === i && i !== q.correct) btn.classList.add('incorrect');
  });

  const quiz = document.getElementById('quiz');
  const isCorrect = i === q.correct;
  if (isCorrect) score++;

  quiz.innerHTML += `
    <div class="explanation">
      ${isCorrect ? "âœ… Bonne rÃ©ponse !" : `âŒ Mauvaise rÃ©ponse.<br><strong>Bonne rÃ©ponse :</strong> ${q.choices[q.correct]}`}<br>
      ${q.exp}
    </div>
    <button class="next-btn" onclick="nextQuestion()">Suivant</button>
  `;
}

function nextQuestion() {
  current++;
  if (current < questions.length) {
    showQuestion();
  } else {
    document.getElementById('quiz').innerHTML = `
      <div class="question-box">
        <h2>ğŸ‰ Quiz terminÃ© !</h2>
        <p>Score : ${score} / ${questions.length}</p>
        <button class="next-btn" onclick="restart()">Recommencer</button>
      </div>
    `;
  }
}

function restart() {
  current = 0;
  score = 0;
  showQuestion();
}

showQuestion();
</script>

</body>
</html>
